{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/interfaces/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\ninterface IInterestRateModel {\n    /* solhint-disable */\n    struct Config {\n        // uopt ∈ (0, 1) – optimal utilization;\n        int256 uopt;\n        // ucrit ∈ (uopt, 1) – threshold of large utilization;\n        int256 ucrit;\n        // ulow ∈ (0, uopt) – threshold of low utilization\n        int256 ulow;\n        // ki > 0 – integrator gain\n        int256 ki;\n        // kcrit > 0 – proportional gain for large utilization\n        int256 kcrit;\n        // klow ≥ 0 – proportional gain for low utilization\n        int256 klow;\n        // klin ≥ 0 – coefficient of the lower linear bound\n        int256 klin;\n        // beta ≥ 0 - a scaling factor\n        int256 beta;\n        // ri ≥ 0 – initial value of the integrator\n        int256 ri;\n        // Tcrit ≥ 0 - the time during which the utilization exceeds the critical value\n        int256 Tcrit;\n    }\n    /* solhint-enable */\n\n    /// @dev Set dedicated config for given asset in a Silo. Config is per asset per Silo so different assets\n    /// in different Silo can have different configs.\n    /// It will try to call `_silo.accrueInterest(_asset)` before updating config, but it is not guaranteed,\n    /// that this call will be successful, if it fail config will be set anyway.\n    /// @param _silo Silo address for which config should be set\n    /// @param _asset asset address for which config should be set\n    function setConfig(address _silo, address _asset, Config calldata _config) external;\n\n    /// @dev get compound interest rate and update model storage\n    /// @param _asset address of an asset in Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    function getCompoundInterestRateAndUpdate(\n        address _asset,\n        uint256 _blockTimestamp\n    ) external returns (uint256 rcomp);\n\n    /// @dev Get config for given asset in a Silo. If dedicated config is not set, default one will be returned.\n    /// @param _silo Silo address for which config should be set\n    /// @param _asset asset address for which config should be set\n    /// @return Config struct for asset in Silo\n    function getConfig(address _silo, address _asset) external view returns (Config memory);\n\n    /// @dev get compound interest rate\n    /// @param _silo address of Silo\n    /// @param _asset address of an asset in Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    function getCompoundInterestRate(\n        address _silo,\n        address _asset,\n        uint256 _blockTimestamp\n    ) external view returns (uint256 rcomp);\n\n    /// @dev get current annual interest rate\n    /// @param _silo address of Silo\n    /// @param _asset address of an asset in Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcur current annual interest rate (1e18 == 100%)\n    function getCurrentInterestRate(\n        address _silo,\n        address _asset,\n        uint256 _blockTimestamp\n    ) external view returns (uint256 rcur);\n\n    /// @notice get the flag to detect rcomp restriction (zero current interest) due to overflow\n    /// overflow boolean flag to detect rcomp restriction\n    function overflowDetected(\n        address _silo,\n        address _asset,\n        uint256 _blockTimestamp\n    ) external view returns (bool overflow);\n\n    /// @dev pure function that calculates current annual interest rate\n    /// @param _c configuration object, InterestRateModel.Config\n    /// @param _totalBorrowAmount current total borrows for asset\n    /// @param _totalDeposits current total deposits for asset\n    /// @param _interestRateTimestamp timestamp of last interest rate update\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcur current annual interest rate (1e18 == 100%)\n    function calculateCurrentInterestRate(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) external pure returns (uint256 rcur);\n\n    /// @dev pure function that calculates interest rate based on raw input data\n    /// @param _c configuration object, InterestRateModel.Config\n    /// @param _totalBorrowAmount current total borrows for asset\n    /// @param _totalDeposits current total deposits for asset\n    /// @param _interestRateTimestamp timestamp of last interest rate update\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    /// @return ri current integral part of the rate\n    /// @return Tcrit time during which the utilization exceeds the critical value\n    /// @return overflow boolean flag to detect rcomp restriction\n    function calculateCompoundInterestRateWithOverflowDetection(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) external pure returns (\n        uint256 rcomp,\n        int256 ri,\n        int256 Tcrit, // solhint-disable-line var-name-mixedcase\n        bool overflow\n    );\n\n    /// @dev pure function that calculates interest rate based on raw input data\n    /// @param _c configuration object, InterestRateModel.Config\n    /// @param _totalBorrowAmount current total borrows for asset\n    /// @param _totalDeposits current total deposits for asset\n    /// @param _interestRateTimestamp timestamp of last interest rate update\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    /// @return ri current integral part of the rate\n    /// @return Tcrit time during which the utilization exceeds the critical value\n    function calculateCompoundInterestRate(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) external pure returns (\n        uint256 rcomp,\n        int256 ri,\n        int256 Tcrit // solhint-disable-line var-name-mixedcase\n    );\n\n    /// @dev returns decimal points used by model\n    function DP() external pure returns (uint256); // solhint-disable-line func-name-mixedcase\n\n    /// @dev just a helper method to see if address is a InterestRateModel\n    /// @return always true\n    function interestRateModelPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/INotificationReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\n/// @title Common interface for Silo Incentive Contract\ninterface INotificationReceiver {\n    /// @dev Informs the contract about token transfer\n    /// @param _token address of the token that was transferred\n    /// @param _from sender\n    /// @param _to receiver\n    /// @param _amount amount that was transferred\n    function onAfterTransfer(address _token, address _from, address _to, uint256 _amount) external;\n\n    /// @dev Sanity check function\n    /// @return always true\n    function notificationReceiverPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\n/// @title Common interface for Silo Price Providers\ninterface IPriceProvider {\n    /// @notice Returns \"Time-Weighted Average Price\" for an asset. Calculates TWAP price for quote/asset.\n    /// It unifies all tokens decimal to 18, examples:\n    /// - if asses == quote it returns 1e18\n    /// - if asset is USDC and quote is ETH and ETH costs ~$3300 then it returns ~0.0003e18 WETH per 1 USDC\n    /// @param _asset address of an asset for which to read price\n    /// @return price of asses with 18 decimals, throws when pool is not ready yet to provide price\n    function getPrice(address _asset) external view returns (uint256 price);\n\n    /// @dev Informs if PriceProvider is setup for asset. It does not means PriceProvider can provide price right away.\n    /// Some providers implementations need time to \"build\" buffer for TWAP price,\n    /// so price may not be available yet but this method will return true.\n    /// @param _asset asset in question\n    /// @return TRUE if asset has been setup, otherwise false\n    function assetSupported(address _asset) external view returns (bool);\n\n    /// @notice Gets token address in which prices are quoted\n    /// @return quoteToken address\n    function quoteToken() external view returns (address);\n\n    /// @notice Helper method that allows easily detects, if contract is PriceProvider\n    /// @dev this can save us from simple human errors, in case we use invalid address\n    /// but this should NOT be treated as security check\n    /// @return always true\n    function priceProviderPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IPriceProvidersRepository.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IPriceProvidersRepository {\n    /// @notice Emitted when price provider is added\n    /// @param newPriceProvider new price provider address\n    event NewPriceProvider(IPriceProvider indexed newPriceProvider);\n\n    /// @notice Emitted when price provider is removed\n    /// @param priceProvider removed price provider address\n    event PriceProviderRemoved(IPriceProvider indexed priceProvider);\n\n    /// @notice Emitted when asset is assigned to price provider\n    /// @param asset assigned asset   address\n    /// @param priceProvider price provider address\n    event PriceProviderForAsset(address indexed asset, IPriceProvider indexed priceProvider);\n\n    /// @notice Register new price provider\n    /// @param _priceProvider address of price provider\n    function addPriceProvider(IPriceProvider _priceProvider) external;\n\n    /// @notice Unregister price provider\n    /// @param _priceProvider address of price provider to be removed\n    function removePriceProvider(IPriceProvider _priceProvider) external;\n\n    /// @notice Sets price provider for asset\n    /// @dev Request for asset price is forwarded to the price provider assigned to that asset\n    /// @param _asset address of an asset for which price provider will be used\n    /// @param _priceProvider address of price provider\n    function setPriceProviderForAsset(address _asset, IPriceProvider _priceProvider) external;\n\n    /// @notice Returns \"Time-Weighted Average Price\" for an asset\n    /// @param _asset address of an asset for which to read price\n    /// @return price TWAP price of a token with 18 decimals\n    function getPrice(address _asset) external view returns (uint256 price);\n\n    /// @notice Gets price provider assigned to an asset\n    /// @param _asset address of an asset for which to get price provider\n    /// @return priceProvider address of price provider\n    function priceProviders(address _asset) external view returns (IPriceProvider priceProvider);\n\n    /// @notice Gets token address in which prices are quoted\n    /// @return quoteToken address\n    function quoteToken() external view returns (address);\n\n    /// @notice Gets manager role address\n    /// @return manager role address\n    function manager() external view returns (address);\n\n    /// @notice Checks if providers are available for an asset\n    /// @param _asset asset address to check\n    /// @return returns TRUE if price feed is ready, otherwise false\n    function providersReadyForAsset(address _asset) external view returns (bool);\n\n    /// @notice Returns true if address is a registered price provider\n    /// @param _provider address of price provider to be removed\n    /// @return true if address is a registered price provider, otherwise false\n    function isPriceProvider(IPriceProvider _provider) external view returns (bool);\n\n    /// @notice Gets number of price providers registered\n    /// @return number of price providers registered\n    function providersCount() external view returns (uint256);\n\n    /// @notice Gets an array of price providers\n    /// @return array of price providers\n    function providerList() external view returns (address[] memory);\n\n    /// @notice Sanity check function\n    /// @return returns always TRUE\n    function priceProvidersRepositoryPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IShareToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./INotificationReceiver.sol\";\n\ninterface IShareToken is IERC20Metadata {\n    /// @notice Emitted every time receiver is notified about token transfer\n    /// @param notificationReceiver receiver address\n    /// @param success false if TX reverted on `notificationReceiver` side, otherwise true\n    event NotificationSent(\n        INotificationReceiver indexed notificationReceiver,\n        bool success\n    );\n\n    /// @notice Mint method for Silo to create debt position\n    /// @param _account wallet for which to mint token\n    /// @param _amount amount of token to be minted\n    function mint(address _account, uint256 _amount) external;\n\n    /// @notice Burn method for Silo to close debt position\n    /// @param _account wallet for which to burn token\n    /// @param _amount amount of token to be burned\n    function burn(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/ISiloFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\ninterface ISiloFactory {\n    /// @notice Emitted when Silo is deployed\n    /// @param silo address of deployed Silo\n    /// @param asset address of asset for which Silo was deployed\n    /// @param version version of silo implementation\n    event NewSiloCreated(address indexed silo, address indexed asset, uint128 version);\n\n    /// @notice Must be called by repository on constructor\n    /// @param _siloRepository the SiloRepository to set\n    function initRepository(address _siloRepository) external;\n\n    /// @notice Deploys Silo\n    /// @param _siloAsset unique asset for which Silo is deployed\n    /// @param _version version of silo implementation\n    /// @param _data (optional) data that may be needed during silo creation\n    /// @return silo deployed Silo address\n    function createSilo(address _siloAsset, uint128 _version, bytes memory _data) external returns (address silo);\n\n    /// @dev just a helper method to see if address is a factory\n    function siloFactoryPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/ISiloRepository.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"./ISiloFactory.sol\";\nimport \"./ITokensFactory.sol\";\nimport \"./IPriceProvidersRepository.sol\";\nimport \"./INotificationReceiver.sol\";\nimport \"./IInterestRateModel.sol\";\n\ninterface ISiloRepository {\n    /// @dev protocol fees in precision points (Solvency._PRECISION_DECIMALS), we do allow for fee == 0\n    struct Fees {\n        /// @dev One time protocol fee for opening a borrow position in precision points (Solvency._PRECISION_DECIMALS)\n        uint64 entryFee;\n        /// @dev Protocol revenue share in interest paid in precision points (Solvency._PRECISION_DECIMALS)\n        uint64 protocolShareFee;\n        /// @dev Protocol share in liquidation profit in precision points (Solvency._PRECISION_DECIMALS).\n        /// It's calculated from total collateral amount to be transferred to liquidator.\n        uint64 protocolLiquidationFee;\n    }\n\n    struct SiloVersion {\n        /// @dev Default version of Silo. If set to 0, it means it is not set. By default it is set to 1\n        uint128 byDefault;\n\n        /// @dev Latest added version of Silo. If set to 0, it means it is not set. By default it is set to 1\n        uint128 latest;\n    }\n\n    /// @dev AssetConfig struct represents configurable parameters for each Silo\n    struct AssetConfig {\n        /// @dev Loan-to-Value ratio represents the maximum borrowing power of a specific collateral.\n        ///      For example, if the collateral asset has an LTV of 75%, the user can borrow up to 0.75 worth\n        ///      of quote token in the principal currency for every quote token worth of collateral.\n        ///      value uses 18 decimals eg. 100% == 1e18\n        ///      max valid value is 1e18 so it needs storage of 60 bits\n        uint64 maxLoanToValue;\n\n        /// @dev Liquidation Threshold represents the threshold at which a borrow position will be considered\n        ///      undercollateralized and subject to liquidation for each collateral. For example,\n        ///      if a collateral has a liquidation threshold of 80%, it means that the loan will be\n        ///      liquidated when the borrowAmount value is worth 80% of the collateral value.\n        ///      value uses 18 decimals eg. 100% == 1e18\n        uint64 liquidationThreshold;\n\n        /// @dev interest rate model address\n        IInterestRateModel interestRateModel;\n    }\n\n    event NewDefaultMaximumLTV(uint64 defaultMaximumLTV);\n\n    event NewDefaultLiquidationThreshold(uint64 defaultLiquidationThreshold);\n\n    /// @notice Emitted on new Silo creation\n    /// @param silo deployed Silo address\n    /// @param asset unique asset for deployed Silo\n    /// @param siloVersion version of deployed Silo\n    event NewSilo(address indexed silo, address indexed asset, uint128 siloVersion);\n\n    /// @notice Emitted when new Silo (or existing one) becomes a bridge pool (pool with only bridge tokens).\n    /// @param pool address of the bridge pool, It can be zero address when bridge asset is removed and pool no longer\n    /// is treated as bridge pool\n    event BridgePool(address indexed pool);\n\n    /// @notice Emitted on new bridge asset\n    /// @param newBridgeAsset address of added bridge asset\n    event BridgeAssetAdded(address indexed newBridgeAsset);\n\n    /// @notice Emitted on removed bridge asset\n    /// @param bridgeAssetRemoved address of removed bridge asset\n    event BridgeAssetRemoved(address indexed bridgeAssetRemoved);\n\n    /// @notice Emitted when default interest rate model is changed\n    /// @param newModel address of new interest rate model\n    event InterestRateModel(IInterestRateModel indexed newModel);\n\n    /// @notice Emitted on price provider repository address update\n    /// @param newProvider address of new oracle repository\n    event PriceProvidersRepositoryUpdate(\n        IPriceProvidersRepository indexed newProvider\n    );\n\n    /// @notice Emitted on token factory address update\n    /// @param newTokensFactory address of new token factory\n    event TokensFactoryUpdate(address indexed newTokensFactory);\n\n    /// @notice Emitted on router address update\n    /// @param newRouter address of new router\n    event RouterUpdate(address indexed newRouter);\n\n    /// @notice Emitted on INotificationReceiver address update\n    /// @param newIncentiveContract address of new INotificationReceiver\n    event NotificationReceiverUpdate(INotificationReceiver indexed newIncentiveContract);\n\n    /// @notice Emitted when new Silo version is registered\n    /// @param factory factory address that deploys registered Silo version\n    /// @param siloLatestVersion Silo version of registered Silo\n    /// @param siloDefaultVersion current default Silo version\n    event RegisterSiloVersion(address indexed factory, uint128 siloLatestVersion, uint128 siloDefaultVersion);\n\n    /// @notice Emitted when Silo version is unregistered\n    /// @param factory factory address that deploys unregistered Silo version\n    /// @param siloVersion version that was unregistered\n    event UnregisterSiloVersion(address indexed factory, uint128 siloVersion);\n\n    /// @notice Emitted when default Silo version is updated\n    /// @param newDefaultVersion new default version\n    event SiloDefaultVersion(uint128 newDefaultVersion);\n\n    /// @notice Emitted when default fee is updated\n    /// @param newEntryFee new entry fee\n    /// @param newProtocolShareFee new protocol share fee\n    /// @param newProtocolLiquidationFee new protocol liquidation fee\n    event FeeUpdate(\n        uint64 newEntryFee,\n        uint64 newProtocolShareFee,\n        uint64 newProtocolLiquidationFee\n    );\n\n    /// @notice Emitted when asset config is updated for a silo\n    /// @param silo silo for which asset config is being set\n    /// @param asset asset for which asset config is being set\n    /// @param assetConfig new asset config\n    event AssetConfigUpdate(address indexed silo, address indexed asset, AssetConfig assetConfig);\n\n    /// @notice Emitted when silo (silo factory) version is set for asset\n    /// @param asset asset for which asset config is being set\n    /// @param version Silo version\n    event VersionForAsset(address indexed asset, uint128 version);\n\n    /// @param _siloAsset silo asset\n    /// @return version of Silo that is assigned for provided asset, if not assigned it returns zero (default)\n    function getVersionForAsset(address _siloAsset) external returns (uint128);\n\n    /// @notice setter for `getVersionForAsset` mapping\n    /// @param _siloAsset silo asset\n    /// @param _version version of Silo that will be assigned for `_siloAsset`, zero (default) is acceptable\n    function setVersionForAsset(address _siloAsset, uint128 _version) external;\n\n    /// @notice use this method only when off-chain verification is OFF\n    /// @dev Silo does NOT support rebase and deflationary tokens\n    /// @param _siloAsset silo asset\n    /// @param _siloData (optional) data that may be needed during silo creation\n    /// @return createdSilo address of created silo\n    function newSilo(address _siloAsset, bytes memory _siloData) external returns (address createdSilo);\n\n    /// @notice use this method to deploy new version of Silo for an asset that already has Silo deployed.\n    /// Only owner (DAO) can replace.\n    /// @dev Silo does NOT support rebase and deflationary tokens\n    /// @param _siloAsset silo asset\n    /// @param _siloVersion version of silo implementation. Use 0 for default version which is fine\n    /// for 99% of cases.\n    /// @param _siloData (optional) data that may be needed during silo creation\n    /// @return createdSilo address of created silo\n    function replaceSilo(\n        address _siloAsset,\n        uint128 _siloVersion,\n        bytes memory _siloData\n    ) external returns (address createdSilo);\n\n    /// @notice Set factory contract for debt and collateral tokens for each Silo asset\n    /// @dev Callable only by owner\n    /// @param _tokensFactory address of TokensFactory contract that deploys debt and collateral tokens\n    function setTokensFactory(address _tokensFactory) external;\n\n    /// @notice Set default fees\n    /// @dev Callable only by owner\n    /// @param _fees:\n    /// - _entryFee one time protocol fee for opening a borrow position in precision points\n    /// (Solvency._PRECISION_DECIMALS)\n    /// - _protocolShareFee protocol revenue share in interest paid in precision points\n    /// (Solvency._PRECISION_DECIMALS)\n    /// - _protocolLiquidationFee protocol share in liquidation profit in precision points\n    /// (Solvency._PRECISION_DECIMALS). It's calculated from total collateral amount to be transferred\n    /// to liquidator.\n    function setFees(Fees calldata _fees) external;\n\n    /// @notice Set configuration for given asset in given Silo\n    /// @dev Callable only by owner\n    /// @param _silo Silo address for which config applies\n    /// @param _asset asset address for which config applies\n    /// @param _assetConfig:\n    ///    - _maxLoanToValue maximum Loan-to-Value, for details see `Repository.AssetConfig.maxLoanToValue`\n    ///    - _liquidationThreshold liquidation threshold, for details see `Repository.AssetConfig.maxLoanToValue`\n    ///    - _interestRateModel interest rate model address, for details see `Repository.AssetConfig.interestRateModel`\n    function setAssetConfig(\n        address _silo,\n        address _asset,\n        AssetConfig calldata _assetConfig\n    ) external;\n\n    /// @notice Set default interest rate model\n    /// @dev Callable only by owner\n    /// @param _defaultInterestRateModel default interest rate model\n    function setDefaultInterestRateModel(IInterestRateModel _defaultInterestRateModel) external;\n\n    /// @notice Set default maximum LTV\n    /// @dev Callable only by owner\n    /// @param _defaultMaxLTV default maximum LTV in precision points (Solvency._PRECISION_DECIMALS)\n    function setDefaultMaximumLTV(uint64 _defaultMaxLTV) external;\n\n    /// @notice Set default liquidation threshold\n    /// @dev Callable only by owner\n    /// @param _defaultLiquidationThreshold default liquidation threshold in precision points\n    /// (Solvency._PRECISION_DECIMALS)\n    function setDefaultLiquidationThreshold(uint64 _defaultLiquidationThreshold) external;\n\n    /// @notice Set price provider repository\n    /// @dev Callable only by owner\n    /// @param _repository price provider repository address\n    function setPriceProvidersRepository(IPriceProvidersRepository _repository) external;\n\n    /// @notice Set router contract\n    /// @dev Callable only by owner\n    /// @param _router router address\n    function setRouter(address _router) external;\n\n    /// @notice Set NotificationReceiver contract\n    /// @dev Callable only by owner\n    /// @param _silo silo address for which to set `_notificationReceiver`\n    /// @param _notificationReceiver NotificationReceiver address\n    function setNotificationReceiver(address _silo, INotificationReceiver _notificationReceiver) external;\n\n    /// @notice Adds new bridge asset\n    /// @dev New bridge asset must be unique. Duplicates in bridge assets are not allowed. It's possible to add\n    /// bridge asset that has been removed in the past. Note that all Silos must be synced manually. Callable\n    /// only by owner.\n    /// @param _newBridgeAsset bridge asset address\n    function addBridgeAsset(address _newBridgeAsset) external;\n\n    /// @notice Removes bridge asset\n    /// @dev Note that all Silos must be synced manually. Callable only by owner.\n    /// @param _bridgeAssetToRemove bridge asset address to be removed\n    function removeBridgeAsset(address _bridgeAssetToRemove) external;\n\n    /// @notice Registers new Silo version\n    /// @dev User can choose which Silo version he wants to deploy. It's possible to have multiple versions of Silo.\n    /// Callable only by owner.\n    /// @param _factory factory contract that deploys new version of Silo\n    /// @param _isDefault true if this version should be used as default\n    function registerSiloVersion(ISiloFactory _factory, bool _isDefault) external;\n\n    /// @notice Unregisters Silo version\n    /// @dev Callable only by owner.\n    /// @param _siloVersion Silo version to be unregistered\n    function unregisterSiloVersion(uint128 _siloVersion) external;\n\n    /// @notice Sets default Silo version\n    /// @dev Callable only by owner.\n    /// @param _defaultVersion Silo version to be set as default\n    function setDefaultSiloVersion(uint128 _defaultVersion) external;\n\n    /// @notice Check if contract address is a Silo deployment\n    /// @param _silo address of expected Silo\n    /// @return true if address is Silo deployment, otherwise false\n    function isSilo(address _silo) external view returns (bool);\n\n    /// @notice Get Silo address of asset\n    /// @param _asset address of asset\n    /// @return address of corresponding Silo deployment\n    function getSilo(address _asset) external view returns (address);\n\n    /// @notice Get Silo Factory for given version\n    /// @param _siloVersion version of Silo implementation\n    /// @return ISiloFactory contract that deploys Silos of given version\n    function siloFactory(uint256 _siloVersion) external view returns (ISiloFactory);\n\n    /// @notice Get debt and collateral Token Factory\n    /// @return ITokensFactory contract that deploys debt and collateral tokens\n    function tokensFactory() external view returns (ITokensFactory);\n\n    /// @notice Get Router contract\n    /// @return address of router contract\n    function router() external view returns (address);\n\n    /// @notice Get current bridge assets\n    /// @dev Keep in mind that not all Silos may be synced with current bridge assets so it's possible that some\n    /// assets in that list are not part of given Silo.\n    /// @return address array of bridge assets\n    function getBridgeAssets() external view returns (address[] memory);\n\n    /// @notice Get removed bridge assets\n    /// @dev Keep in mind that not all Silos may be synced with bridge assets so it's possible that some\n    /// assets in that list are still part of given Silo.\n    /// @return address array of bridge assets\n    function getRemovedBridgeAssets() external view returns (address[] memory);\n\n    /// @notice Get maximum LTV for asset in given Silo\n    /// @dev If dedicated config is not set, method returns default config\n    /// @param _silo address of Silo\n    /// @param _asset address of an asset\n    /// @return maximum LTV in precision points (Solvency._PRECISION_DECIMALS)\n    function getMaximumLTV(address _silo, address _asset) external view returns (uint256);\n\n    /// @notice Get Interest Rate Model address for asset in given Silo\n    /// @dev If dedicated config is not set, method returns default config\n    /// @param _silo address of Silo\n    /// @param _asset address of an asset\n    /// @return address of interest rate model\n    function getInterestRateModel(address _silo, address _asset) external view returns (IInterestRateModel);\n\n    /// @notice Get liquidation threshold for asset in given Silo\n    /// @dev If dedicated config is not set, method returns default config\n    /// @param _silo address of Silo\n    /// @param _asset address of an asset\n    /// @return liquidation threshold in precision points (Solvency._PRECISION_DECIMALS)\n    function getLiquidationThreshold(address _silo, address _asset) external view returns (uint256);\n\n    /// @notice Get incentive contract address. Incentive contracts are responsible for distributing rewards\n    /// to debt and/or collateral token holders of given Silo\n    /// @param _silo address of Silo\n    /// @return incentive contract address\n    function getNotificationReceiver(address _silo) external view returns (INotificationReceiver);\n\n    /// @notice Get owner role address of Repository\n    /// @return owner role address\n    function owner() external view returns (address);\n\n    /// @notice get PriceProvidersRepository contract that manages price providers implementations\n    /// @return IPriceProvidersRepository address\n    function priceProvidersRepository() external view returns (IPriceProvidersRepository);\n\n    /// @dev Get protocol fee for opening a borrow position\n    /// @return fee in precision points (Solvency._PRECISION_DECIMALS == 100%)\n    function entryFee() external view returns (uint256);\n\n    /// @dev Get protocol share fee\n    /// @return protocol share fee in precision points (Solvency._PRECISION_DECIMALS == 100%)\n    function protocolShareFee() external view returns (uint256);\n\n    /// @dev Get protocol liquidation fee\n    /// @return protocol liquidation fee in precision points (Solvency._PRECISION_DECIMALS == 100%)\n    function protocolLiquidationFee() external view returns (uint256);\n\n    /// @dev Checks all conditions for new silo creation and throws when not possible to create\n    /// @param _asset address of asset for which you want to create silo\n    /// @param _assetIsABridge bool TRUE when `_asset` is bridge asset, FALSE when it is not\n    function ensureCanCreateSiloFor(address _asset, bool _assetIsABridge) external view;\n\n    function siloRepositoryPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/ITokensFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"./IShareToken.sol\";\n\ninterface ITokensFactory {\n    /// @notice Emitted when collateral token is deployed\n    /// @param token address of deployed collateral token\n    event NewShareCollateralTokenCreated(address indexed token);\n\n    /// @notice Emitted when collateral token is deployed\n    /// @param token address of deployed debt token\n    event NewShareDebtTokenCreated(address indexed token);\n\n    ///@notice Must be called by repository on constructor\n    /// @param _siloRepository the SiloRepository to set\n    function initRepository(address _siloRepository) external;\n\n    /// @notice Deploys collateral token\n    /// @param _name name of the token\n    /// @param _symbol symbol of the token\n    /// @param _asset underlying asset for which token is deployed\n    /// @return address of deployed collateral share token\n    function createShareCollateralToken(\n        string memory _name,\n        string memory _symbol,\n        address _asset\n    ) external returns (IShareToken);\n\n    /// @notice Deploys debt token\n    /// @param _name name of the token\n    /// @param _symbol symbol of the token\n    /// @param _asset underlying asset for which token is deployed\n    /// @return address of deployed debt share token\n    function createShareDebtToken(\n        string memory _name,\n        string memory _symbol,\n        address _asset\n    )\n        external\n        returns (IShareToken);\n\n    /// @dev just a helper method to see if address is a factory\n    /// @return always true\n    function tokensFactoryPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/lib/Ping.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\n\nlibrary Ping {\n    function pong(function() external pure returns(bytes4) pingFunction) internal pure returns (bool) {\n        return pingFunction.address != address(0) && pingFunction.selector == pingFunction();\n    }\n}\n"
    },
    "contracts/lib/TokenHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n\nlibrary TokenHelper {\n    uint256 private constant _BYTES32_SIZE = 32;\n\n    error TokenIsNotAContract();\n\n    function assertAndGetDecimals(address _token) internal view returns (uint256) {\n        (bool hasMetadata, bytes memory data) = _tokenMetadataCall(_token, abi.encodeCall(IERC20Metadata.decimals,()));\n\n        // decimals() is optional in the ERC20 standard, so if metadata is not accessible\n        // we assume there are no decimals and use 0.\n        if (!hasMetadata) {\n            return 0;\n        }\n\n        return abi.decode(data, (uint8));\n    }\n\n    /// @dev Returns the symbol for the provided ERC20 token.\n    /// An empty string is returned if the call to the token didn't succeed.\n    /// @param _token address of the token to get the symbol for\n    /// @return assetSymbol the token symbol\n    function symbol(address _token) internal view returns (string memory assetSymbol) {\n        (bool hasMetadata, bytes memory data) = _tokenMetadataCall(_token, abi.encodeCall(IERC20Metadata.symbol,()));\n\n        if (!hasMetadata || data.length == 0) {\n            return \"?\";\n        } else if (data.length == _BYTES32_SIZE) {\n            return string(removeZeros(data));\n        } else {\n            return abi.decode(data, (string));\n        }\n    }\n\n    /// @dev Removes bytes with value equal to 0 from the provided byte array.\n    /// @param _data byte array from which to remove zeroes\n    /// @return result byte array with zeroes removed \n    function removeZeros(bytes memory _data) internal pure returns (bytes memory result) {\n        uint256 n = _data.length;\n\n        unchecked {\n            for (uint256 i; i < n; i++) {\n                if (_data[i] == 0) continue;\n\n                result = abi.encodePacked(result, _data[i]);\n            }\n        }\n    }\n\n    /// @dev Performs a staticcall to the token to get its metadata (symbol, decimals, name)\n    function _tokenMetadataCall(address _token, bytes memory _data) private view returns(bool, bytes memory) {\n        // We need to do this before the call, otherwise the call will succeed even for EOAs\n        if (!Address.isContract(_token)) revert TokenIsNotAContract();\n\n        (bool success, bytes memory result) = _token.staticcall(_data);\n\n        // If the call reverted we assume the token doesn't follow the metadata extension\n        if (!success) {\n            return (false, \"\");\n        }\n\n        return (true, result);\n    }\n}\n"
    },
    "contracts/mock/MockPriceFetchersRepository.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"../PriceProvidersRepository.sol\";\nimport \"../interfaces/IPriceProvider.sol\";\n\n/// @dev this is MOCK contract - DO NOT USE IT!\ncontract MockPriceProvidersRepository is PriceProvidersRepository {\n    mapping(address => uint256) public prices;\n\n    constructor(address _quoteToken, address _factory) PriceProvidersRepository(_quoteToken, _factory) {\n    }\n\n    function setPriceProviderForAsset(address _asset, IPriceProvider _provider) external override {\n        require(\n            Ping.pong(_provider.priceProviderPing),\n                \"ProvidersRepository: not an provider\"\n        );\n\n        priceProviders[_asset] = _provider;\n    }\n\n    function setPrice(address _asset, uint256 _price) public {\n        prices[_asset] = _price;\n    }\n\n    function getPrice(address _asset) public view override returns (uint256) {\n        return prices[_asset];\n    }\n}\n"
    },
    "contracts/PriceProvidersRepository.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./interfaces/IPriceProvidersRepository.sol\";\nimport \"./interfaces/ISiloRepository.sol\";\nimport \"./utils/Manageable.sol\";\nimport \"./utils/TwoStepOwnable.sol\";\n\nimport \"./lib/TokenHelper.sol\";\nimport \"./lib/Ping.sol\";\n\n/// @title PriceProvidersRepository\n/// @notice A repository of price providers. It manages price providers as well as maps assets to their price\n/// provider. It acts as a entry point for Silo for token prices.\n/// @custom:security-contact security@silo.finance\ncontract PriceProvidersRepository is IPriceProvidersRepository, Manageable, TwoStepOwnable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev we require quote token to have 18 decimals\n    uint256 public constant QUOTE_TOKEN_DECIMALS = 18;\n\n    /// @dev Constant used for prices' decimal points, 1e18 is treated as 1\n    uint256 private constant _ONE = 1e18;\n\n    /// @notice SiloRepository contract address\n    address public immutable siloRepository;\n    /// @notice Token in which prices are quoted. It's most likely WETH, however it could vary from deployment\n    /// to deployment. For example 1 SILO costs X amount of quoteToken.\n    address public immutable override quoteToken;\n\n    /// @notice Maps asset address to its price provider\n    /// @dev Each asset must have a price provider contract assigned, otherwise it's not supported\n    mapping(address => IPriceProvider) public override priceProviders;\n\n    /// @notice Array of all price providers\n    EnumerableSet.AddressSet private _allProviders;\n\n    error AssetNotSupported();\n    error InvalidPriceProvider();\n    error InvalidPriceProviderQuoteToken();\n    error InvalidRepository();\n    error OnlyRepository();\n    error PriceProviderAlreadyExists();\n    error PriceProviderDoesNotExist();\n    error PriceProviderNotRegistered();\n    error QuoteTokenNotSupported();\n\n    modifier onlyRepository() {\n        if (msg.sender != siloRepository) revert OnlyRepository();\n        _;\n    }\n\n    /// @param _quoteToken address of quote token\n    /// @param _siloRepository address of SiloRepository\n    constructor(address _quoteToken, address _siloRepository) Manageable(msg.sender) {\n        if (TokenHelper.assertAndGetDecimals(_quoteToken) != QUOTE_TOKEN_DECIMALS) {\n          revert QuoteTokenNotSupported();\n        }\n\n        if (!Ping.pong(ISiloRepository(_siloRepository).siloRepositoryPing)) {\n            revert InvalidRepository();\n        }\n\n        siloRepository = _siloRepository;\n        quoteToken = _quoteToken;\n    }\n\n    /// @inheritdoc IPriceProvidersRepository\n    function addPriceProvider(IPriceProvider _provider) external override onlyOwner {\n        if (!Ping.pong(_provider.priceProviderPing)) revert InvalidPriceProvider();\n\n        if (_provider.quoteToken() != quoteToken) revert InvalidPriceProviderQuoteToken();\n\n        if (!_allProviders.add(address(_provider))) revert PriceProviderAlreadyExists();\n\n        emit NewPriceProvider(_provider);\n    }\n\n    /// @inheritdoc IPriceProvidersRepository\n    function removePriceProvider(IPriceProvider _provider) external virtual override onlyOwner {\n        if (!_allProviders.remove(address(_provider))) revert PriceProviderDoesNotExist();\n\n        emit PriceProviderRemoved(_provider);\n    }\n\n    /// @inheritdoc IPriceProvidersRepository\n    function setPriceProviderForAsset(address _asset, IPriceProvider _provider) external virtual override onlyManager {\n        if (!_allProviders.contains(address(_provider))) {\n            revert PriceProviderNotRegistered();\n        }\n\n        if (!_provider.assetSupported(_asset)) revert AssetNotSupported();\n\n        emit PriceProviderForAsset(_asset, _provider);\n        priceProviders[_asset] = _provider;\n    }\n\n    /// @inheritdoc IPriceProvidersRepository\n    function isPriceProvider(IPriceProvider _provider) external view override returns (bool) {\n        return _allProviders.contains(address(_provider));\n    }\n\n    /// @inheritdoc IPriceProvidersRepository\n    function providersCount() external view override returns (uint256) {\n        return _allProviders.length();\n    }\n\n    /// @inheritdoc IPriceProvidersRepository\n    function providerList() external view override returns (address[] memory) {\n        return _allProviders.values();\n    }\n\n    /// @inheritdoc IPriceProvidersRepository\n    function providersReadyForAsset(address _asset) external view override returns (bool) {\n        // quote token is supported by default because getPrice() returns _ONE as its price by default\n        if (_asset == quoteToken) return true;\n\n        IPriceProvider priceProvider = priceProviders[_asset];\n        if (address(priceProvider) == address(0)) return false;\n\n        return priceProvider.assetSupported(_asset);\n    }\n\n    /// @inheritdoc IPriceProvidersRepository\n    function priceProvidersRepositoryPing() external pure override returns (bytes4) {\n        return this.priceProvidersRepositoryPing.selector;\n    }\n\n    /// @inheritdoc IPriceProvidersRepository\n    function manager() public view override(Manageable, IPriceProvidersRepository) returns (address) {\n        return Manageable.manager();\n    }\n\n    /// @inheritdoc TwoStepOwnable\n    function owner() public view override(Manageable, TwoStepOwnable) returns (address) {\n        return TwoStepOwnable.owner();\n    }\n\n    /// @inheritdoc IPriceProvidersRepository\n    function getPrice(address _asset) public view override virtual returns (uint256) {\n        if (_asset == quoteToken) return _ONE;\n\n        if (address(priceProviders[_asset]) == address(0)) revert AssetNotSupported();\n\n        return priceProviders[_asset].getPrice(_asset);\n    }\n}\n"
    },
    "contracts/utils/Manageable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\n/// @title Manageable\n/// @notice Implements simple manager role that can be changed by a manger or external owner role\n/// @dev This contract is designed to work with Ownable from openzeppelin\n/// @custom:security-contact security@silo.finance\nabstract contract Manageable {\n    /// @notice wallet address of manager role\n    address private _managerRole;\n\n    /// @notice Emitted when manager is changed\n    /// @param manager new manager address\n    event ManagerChanged(address manager);\n\n    error ManagerIsZero();\n    error OnlyManager();\n    error OnlyOwnerOrManager();\n    error ManagerDidNotChange();\n\n    modifier onlyManager() {\n        if (_managerRole != msg.sender) revert OnlyManager();\n        _;\n    }\n\n    /// @param _manager new manager address\n    constructor(address _manager) {\n        if (_manager == address(0)) revert ManagerIsZero();\n\n        _managerRole = _manager;\n    }\n\n    /// @notice Change manager address\n    /// @dev Callable by manager or external owner role\n    /// @param _manager new manager address\n    function changeManager(address _manager) external {\n        if (msg.sender != owner() && msg.sender != _managerRole) {\n            revert OnlyOwnerOrManager();\n        }\n\n        if (_manager == address(0)) revert ManagerIsZero();\n        if (_manager == _managerRole) revert ManagerDidNotChange();\n\n        _managerRole = _manager;\n        emit ManagerChanged(_manager);\n    }\n\n    function manager() public view virtual returns (address) {\n        return _managerRole;\n    }\n\n    /// @notice Gets external owner role\n    /// @return owner address\n    function owner() public view virtual returns (address);\n}\n"
    },
    "contracts/utils/TwoStepOwnable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\n/// @title TwoStepOwnable\n/// @notice Contract that implements the same functionality as popular Ownable contract from openzeppelin library.\n/// The only difference is that it adds a possibility to transfer ownership in two steps. Single step ownership\n/// transfer is still supported.\n/// @dev Two step ownership transfer is meant to be used by humans to avoid human error. Single step ownership\n/// transfer is meant to be used by smart contracts to avoid over-complicated two step integration. For that reason,\n/// both ways are supported.\nabstract contract TwoStepOwnable {\n    /// @dev current owner\n    address private _owner;\n    /// @dev candidate to an owner\n    address private _pendingOwner;\n\n    /// @notice Emitted when ownership is transferred on `transferOwnership` and `acceptOwnership`\n    /// @param newOwner new owner\n    event OwnershipTransferred(address indexed newOwner);\n    /// @notice Emitted when ownership transfer is proposed, aka pending owner is set\n    /// @param newPendingOwner new proposed/pending owner\n    event OwnershipPending(address indexed newPendingOwner);\n\n    /**\n     *  error OnlyOwner();\n     *  error OnlyPendingOwner();\n     *  error OwnerIsZero();\n     */\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        if (owner() != msg.sender) revert(\"OnlyOwner\");\n        _;\n    }\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) revert(\"OwnerIsZero\");\n        _setOwner(newOwner);\n    }\n\n    /**\n     * @dev Transfers pending ownership of the contract to a new account (`newPendingOwner`) and clears any existing\n     * pending ownership.\n     * Can only be called by the current owner.\n     */\n    function transferPendingOwnership(address newPendingOwner) public virtual onlyOwner {\n        _setPendingOwner(newPendingOwner);\n    }\n\n    /**\n     * @dev Clears the pending ownership.\n     * Can only be called by the current owner.\n     */\n    function removePendingOwnership() public virtual onlyOwner {\n        _setPendingOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a pending owner\n     * Can only be called by the pending owner.\n     */\n    function acceptOwnership() public virtual {\n        if (msg.sender != pendingOwner()) revert(\"OnlyPendingOwner\");\n        _setOwner(pendingOwner());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Sets the new owner and emits the corresponding event.\n     */\n    function _setOwner(address newOwner) private {\n        if (_owner == newOwner) revert(\"OwnerDidNotChange\");\n\n        _owner = newOwner;\n        emit OwnershipTransferred(newOwner);\n\n        if (_pendingOwner != address(0)) {\n            _setPendingOwner(address(0));\n        }\n    }\n\n    /**\n     * @dev Sets the new pending owner and emits the corresponding event.\n     */\n    function _setPendingOwner(address newPendingOwner) private {\n        if (_pendingOwner == newPendingOwner) revert(\"PendingOwnerDidNotChange\");\n\n        _pendingOwner = newPendingOwner;\n        emit OwnershipPending(newPendingOwner);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}