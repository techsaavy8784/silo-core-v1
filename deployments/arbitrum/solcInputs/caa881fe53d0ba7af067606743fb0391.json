{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/external/dia/IDIAOracleV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/// @dev https://docs.diadata.org/documentation/oracle-documentation/access-the-oracle\ninterface IDIAOracleV2 {\n    function getValue(string memory key) external view returns (uint128 latestPrice, uint128 timestampOfLatestPrice);\n}\n"
    },
    "contracts/interfaces/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\n/// @title Common interface for Silo Price Providers\ninterface IPriceProvider {\n    /// @notice Returns \"Time-Weighted Average Price\" for an asset. Calculates TWAP price for quote/asset.\n    /// It unifies all tokens decimal to 18, examples:\n    /// - if asses == quote it returns 1e18\n    /// - if asset is USDC and quote is ETH and ETH costs ~$3300 then it returns ~0.0003e18 WETH per 1 USDC\n    /// @param _asset address of an asset for which to read price\n    /// @return price of asses with 18 decimals, throws when pool is not ready yet to provide price\n    function getPrice(address _asset) external view returns (uint256 price);\n\n    /// @dev Informs if PriceProvider is setup for asset. It does not means PriceProvider can provide price right away.\n    /// Some providers implementations need time to \"build\" buffer for TWAP price,\n    /// so price may not be available yet but this method will return true.\n    /// @param _asset asset in question\n    /// @return TRUE if asset has been setup, otherwise false\n    function assetSupported(address _asset) external view returns (bool);\n\n    /// @notice Gets token address in which prices are quoted\n    /// @return quoteToken address\n    function quoteToken() external view returns (address);\n\n    /// @notice Helper method that allows easily detects, if contract is PriceProvider\n    /// @dev this can save us from simple human errors, in case we use invalid address\n    /// but this should NOT be treated as security check\n    /// @return always true\n    function priceProviderPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IPriceProvidersRepository.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IPriceProvidersRepository {\n    /// @notice Emitted when price provider is added\n    /// @param newPriceProvider new price provider address\n    event NewPriceProvider(IPriceProvider indexed newPriceProvider);\n\n    /// @notice Emitted when price provider is removed\n    /// @param priceProvider removed price provider address\n    event PriceProviderRemoved(IPriceProvider indexed priceProvider);\n\n    /// @notice Emitted when asset is assigned to price provider\n    /// @param asset assigned asset   address\n    /// @param priceProvider price provider address\n    event PriceProviderForAsset(address indexed asset, IPriceProvider indexed priceProvider);\n\n    /// @notice Register new price provider\n    /// @param _priceProvider address of price provider\n    function addPriceProvider(IPriceProvider _priceProvider) external;\n\n    /// @notice Unregister price provider\n    /// @param _priceProvider address of price provider to be removed\n    function removePriceProvider(IPriceProvider _priceProvider) external;\n\n    /// @notice Sets price provider for asset\n    /// @dev Request for asset price is forwarded to the price provider assigned to that asset\n    /// @param _asset address of an asset for which price provider will be used\n    /// @param _priceProvider address of price provider\n    function setPriceProviderForAsset(address _asset, IPriceProvider _priceProvider) external;\n\n    /// @notice Returns \"Time-Weighted Average Price\" for an asset\n    /// @param _asset address of an asset for which to read price\n    /// @return price TWAP price of a token with 18 decimals\n    function getPrice(address _asset) external view returns (uint256 price);\n\n    /// @notice Gets price provider assigned to an asset\n    /// @param _asset address of an asset for which to get price provider\n    /// @return priceProvider address of price provider\n    function priceProviders(address _asset) external view returns (IPriceProvider priceProvider);\n\n    /// @notice Gets token address in which prices are quoted\n    /// @return quoteToken address\n    function quoteToken() external view returns (address);\n\n    /// @notice Gets manager role address\n    /// @return manager role address\n    function manager() external view returns (address);\n\n    /// @notice Checks if providers are available for an asset\n    /// @param _asset asset address to check\n    /// @return returns TRUE if price feed is ready, otherwise false\n    function providersReadyForAsset(address _asset) external view returns (bool);\n\n    /// @notice Returns true if address is a registered price provider\n    /// @param _provider address of price provider to be removed\n    /// @return true if address is a registered price provider, otherwise false\n    function isPriceProvider(IPriceProvider _provider) external view returns (bool);\n\n    /// @notice Gets number of price providers registered\n    /// @return number of price providers registered\n    function providersCount() external view returns (uint256);\n\n    /// @notice Gets an array of price providers\n    /// @return array of price providers\n    function providerList() external view returns (address[] memory);\n\n    /// @notice Sanity check function\n    /// @return returns always TRUE\n    function priceProvidersRepositoryPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IPriceProviderV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\nimport \"./IPriceProvider.sol\";\n\n/// @title Common interface V2 for Silo Price Providers\ninterface IPriceProviderV2 is IPriceProvider {\n    /// @dev for liquidation purposes and for compatibility with naming convention we already using in LiquidationHelper\n    /// we have this method to return on-chain provider that can be useful for liquidation\n    function getFallbackProvider(address _asset) external view returns (IPriceProvider);\n\n    /// @dev this is info method for LiquidationHelper\n    /// @return bool TRUE if provider is off-chain, means it is not a dex\n    function offChainProvider() external pure returns (bool);\n}\n"
    },
    "contracts/lib/Ping.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\n\nlibrary Ping {\n    function pong(function() external pure returns(bytes4) pingFunction) internal pure returns (bool) {\n        return pingFunction.address != address(0) && pingFunction.selector == pingFunction();\n    }\n}\n"
    },
    "contracts/priceProviders/dia/DiaPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../PriceProvider.sol\";\nimport \"../IERC20LikeV2.sol\";\nimport \"../../external/dia/IDIAOracleV2.sol\";\nimport \"../../interfaces/IPriceProviderV2.sol\";\n\ncontract DiaPriceProvider is IPriceProviderV2, PriceProvider {\n    /// @dev price provider needs to return prices in ETH, but assets prices provided by DIA are in USD\n    /// Under ETH_USD_KEY we will find ETH price in USD so we can convert price in USD into price in ETH\n    string public constant ETH_USD_KEY = \"ETH/USD\";\n\n    /// @dev decimals in DIA oracle\n    uint256 public constant DIA_DECIMALS = 1e8;\n\n    /// @dev decimals in Silo protocol\n    uint256 public immutable EXPECTED_DECIMALS; // solhint-disable-line var-name-mixedcase\n\n    /// @dev Oracle deployed for Silo by DIA, all our prices will be submitted to this contract\n    IDIAOracleV2 public immutable DIA_ORACLEV2; // solhint-disable-line var-name-mixedcase\n\n    /// @dev Address of asset that we will be using as reference for USD\n    address public immutable USD_ASSET; // solhint-disable-line var-name-mixedcase\n\n    /// @dev we accessing prices for assets by keys eg. \"Jones/USD\"\n    mapping (address => string) public keys;\n\n    /// @dev asset => fallbackProvider\n    mapping(address => IPriceProvider) public liquidationProviders;\n\n    event AssetSetup(address indexed asset, string key);\n\n    event LiquidationProvider(address indexed asset, IPriceProvider indexed liquidationProvider);\n\n    error MissingETHPrice();\n    error InvalidKey();\n    error CanNotSetEthKey();\n    error OnlyUSDPriceAccepted();\n    error PriceCanNotBeFoundForProvidedKey();\n    error OldPrice();\n    error MissingPriceOrSetup();\n    error LiquidationProviderAlreadySet();\n    error AssetNotSupported();\n    error LiquidationProviderAssetNotSupported();\n    error LiquidationProviderNotExist();\n    error KeyDoesNotMatchSymbol();\n    error FallbackPriceProviderNotSet();\n\n    /// @param _priceProvidersRepository IPriceProvidersRepository\n    /// @param _diaOracle IDIAOracleV2 address of DIA oracle contract\n    /// @param _stableAsset address Address of asset that we will be using as reference for USD\n    /// it has no affect on any price, this is only for be able to getPrice(_usdAsset) using `ETH_USD_KEY` key\n    constructor(\n        IPriceProvidersRepository _priceProvidersRepository,\n        IDIAOracleV2 _diaOracle,\n        address _stableAsset\n    )\n        PriceProvider(_priceProvidersRepository)\n    {\n        EXPECTED_DECIMALS = 10 ** IERC20LikeV2(_priceProvidersRepository.quoteToken()).decimals();\n        USD_ASSET = _stableAsset;\n        DIA_ORACLEV2 = _diaOracle;\n\n        bool allowEthUsdKey = true;\n        _setupAsset(_stableAsset, ETH_USD_KEY, IPriceProvider(address(0)), allowEthUsdKey);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function assetSupported(address _asset) public view virtual override returns (bool) {\n        return bytes(keys[_asset]).length != 0;\n    }\n\n    /// @param _key string under this key asset price will be available in DIA oracle\n    /// @return assetPriceInUsd uint128 asset price\n    /// @return priceUpToDate bool TRUE if price is up to date (acceptable), FALSE otherwise\n    function getPriceForKey(string memory _key)\n        public\n        view\n        virtual\n        returns (uint128 assetPriceInUsd, bool priceUpToDate)\n    {\n        uint128 priceTimestamp;\n        (assetPriceInUsd, priceTimestamp) = DIA_ORACLEV2.getValue(_key);\n\n        // price must be updated at least once every 24h, otherwise something is wrong\n        uint256 oldestAcceptedPriceTimestamp;\n        // block.timestamp is more than 1 day, so we can not underflow\n        unchecked { oldestAcceptedPriceTimestamp = block.timestamp - 1 days; }\n\n        // we not checking assetPriceInUsd != 0, because this is checked on setup, so it will be always some value here\n        priceUpToDate = priceTimestamp > oldestAcceptedPriceTimestamp;\n    }\n\n    function getFallbackPrice(address _asset) public view virtual returns (uint256) {\n        IPriceProvider fallbackProvider = liquidationProviders[_asset];\n\n        if (address(fallbackProvider) != address(0)) {\n            return fallbackProvider.getPrice(_asset);\n        }\n\n        revert FallbackPriceProviderNotSet();\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPrice(address _asset) public view virtual override returns (uint256) {\n        string memory key = keys[_asset];\n\n        if (bytes(key).length == 0) revert AssetNotSupported();\n\n        (uint128 assetPriceInUsd, bool priceUpToDate) = getPriceForKey(key);\n\n        if (!priceUpToDate) {\n            return getFallbackPrice(_asset);\n        }\n\n        if (_asset == USD_ASSET) {\n            unchecked {\n                // multiplication of decimals is safe, this are small values, division is safe as well\n                return DIA_DECIMALS * EXPECTED_DECIMALS / assetPriceInUsd;\n            }\n        }\n\n        (uint128 ethPriceInUsd, bool ethPriceUpToDate) = getPriceForKey(ETH_USD_KEY);\n\n        if (!ethPriceUpToDate) {\n            return getFallbackPrice(_asset);\n        }\n\n        return normalizePrice(assetPriceInUsd, ethPriceInUsd);\n    }\n\n    /// @dev Asset setup. Can only be called by the manager.\n    /// Explanation from DIA team:\n    ///     Updates will be done every time there is a deviation >1% btw the last onchain update and the current price.\n    ///     We have a 24hrs default update though, so assuming the price remains completely flat you would still get\n    ///     an update every 24hrs.\n    /// @param _asset address Asset to setup\n    /// @param _key string under this key asset price will be available in DIA oracle\n    /// @param _liquidationProvider IPriceProvider on-chain provider that can help with liquidation\n    /// it will not be use for providing price, it is only for liquidation process\n    function setupAsset(\n        address _asset,\n        string calldata _key,\n        IPriceProvider _liquidationProvider\n    ) external virtual onlyManager {\n        validateSymbol(_asset, _key);\n\n        bool allowEthUsdKey;\n        _setupAsset(_asset, _key, _liquidationProvider, allowEthUsdKey);\n    }\n    \n    function setLiquidationProvider(address _asset, IPriceProvider _liquidationProvider) public virtual onlyManager {\n        _setLiquidationProvider(_asset, _liquidationProvider);\n    }\n\n    function removeLiquidationProvider(address _asset) public virtual onlyManager {\n        if (address(0) == address(liquidationProviders[_asset])) revert LiquidationProviderNotExist();\n\n        delete liquidationProviders[_asset];\n\n        emit LiquidationProvider(_asset, IPriceProvider(address(0)));\n    }\n\n    /// @dev for liquidation purposes and for compatibility with naming convention we already using in LiquidationHelper\n    /// we have this method to return on-chain provider that can be useful for liquidation\n    function getFallbackProvider(address _asset) external view virtual returns (IPriceProvider) {\n        return liquidationProviders[_asset];\n    }\n\n    /// @dev _assetPriceInUsd uint128 asset price returned by DIA oracle (8 decimals)\n    /// @dev _ethPriceInUsd uint128 ETH price returned by DIA oracle (8 decimals)\n    /// @return assetPriceInEth uint256 18 decimals price in ETH\n    function normalizePrice(uint128 _assetPriceInUsd, uint128 _ethPriceInUsd)\n        public\n        view\n        virtual\n        returns (uint256 assetPriceInEth)\n    {\n        uint256 withDecimals = _assetPriceInUsd * EXPECTED_DECIMALS;\n\n        unchecked {\n            // div is safe\n            return withDecimals / _ethPriceInUsd;\n        }\n    }\n\n    /// @dev checks if key has expected format.\n    /// Atm provider is accepting only prices in USD, so key must end with \"/USD\".\n    /// If key is invalid function will throw.\n    /// @param _key string DIA key for asset\n    function validateKey(string memory _key) public pure virtual {\n        _validateKey(_key, false);\n    }\n\n    /// @dev checks if key match token symbol. Reverts if does not match.\n    /// @param _asset address Asset to setup\n    /// @param _key string under this key asset price will be available in DIA oracle\n    function validateSymbol(address _asset, string memory _key) public view virtual {\n        bytes memory symbol = bytes(IERC20Metadata(_asset).symbol());\n\n        unchecked {\n            // `+4` for `/USD`, we will never have key with length that will overflow\n            if (symbol.length + 4 != bytes(_key).length) revert KeyDoesNotMatchSymbol();\n\n            // we will never have key with length that will overflow, so i++ is safe\n            for (uint256 i; i < symbol.length; i++) {\n                if (symbol[i] != bytes(_key)[i]) revert KeyDoesNotMatchSymbol();\n            }\n        }\n    }\n\n    /// @dev this is info method for LiquidationHelper\n    /// @return bool TRUE if provider is off-chain, means it is not a dex\n    function offChainProvider() external pure virtual returns (bool) {\n        return true;\n    }\n\n    /// @param _allowEthUsd bool use TRUE only when setting up `ETH_USD_KEY` key, FALSE in all other cases\n    // solhint-disable-next-line code-complexity\n    function _validateKey(string memory _key, bool _allowEthUsd) internal pure virtual {\n        if (!_allowEthUsd) {\n            if (keccak256(abi.encodePacked(_key)) == keccak256(abi.encodePacked(ETH_USD_KEY))) revert CanNotSetEthKey();\n        }\n\n        uint256 keyLength = bytes(_key).length;\n\n        if (keyLength < 5) revert InvalidKey();\n\n        unchecked {\n            // keyLength is at least 5, based on above check, so it is safe to uncheck all below subtractions\n            if (bytes(_key)[keyLength - 4] != \"/\") revert OnlyUSDPriceAccepted();\n            if (bytes(_key)[keyLength - 3] != \"U\") revert OnlyUSDPriceAccepted();\n            if (bytes(_key)[keyLength - 2] != \"S\") revert OnlyUSDPriceAccepted();\n            if (bytes(_key)[keyLength - 1] != \"D\") revert OnlyUSDPriceAccepted();\n        }\n    }\n\n    /// @param _asset Asset to setup\n    /// @param _key string under this key asset price will be available in DIA oracle\n    /// @param _liquidationProvider IPriceProvider on-chain provider that can help with liquidation\n    /// it will not be use for providing price, it is only for liquidation process\n    /// @param _allowEthUsd bool use TRUE only when setting up `ETH_USD_KEY` key, FALSE in all other cases\n    function _setupAsset(\n        address _asset,\n        string memory _key,\n        IPriceProvider _liquidationProvider,\n        bool _allowEthUsd\n    ) internal virtual {\n        _validateKey(_key, _allowEthUsd);\n\n        (uint128 latestPrice, bool priceUpToDate) = getPriceForKey(_key);\n\n        if (latestPrice == 0) revert PriceCanNotBeFoundForProvidedKey();\n        if (!priceUpToDate) revert OldPrice();\n\n        keys[_asset] = _key;\n\n        emit AssetSetup(_asset, _key);\n\n        if (address(_liquidationProvider) != address(0)) {\n            _setLiquidationProvider(_asset, _liquidationProvider);\n        }\n    }\n\n    function _setLiquidationProvider(address _asset, IPriceProvider _liquidationProvider) internal virtual {\n        if (!assetSupported(_asset)) revert AssetNotSupported();\n        if (_liquidationProvider == liquidationProviders[_asset]) revert LiquidationProviderAlreadySet();\n        if (!_liquidationProvider.assetSupported(_asset)) revert LiquidationProviderAssetNotSupported();\n\n        liquidationProviders[_asset] = _liquidationProvider;\n\n        emit LiquidationProvider(_asset, _liquidationProvider);\n    }\n}\n"
    },
    "contracts/priceProviders/dia/DiaPriceProviderV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./DiaPriceProvider.sol\";\n\ncontract DiaPriceProviderV2 is DiaPriceProvider {\n    constructor(\n        IPriceProvidersRepository _priceProvidersRepository,\n        IDIAOracleV2 _diaOracle,\n        address _stableAsset\n    ) DiaPriceProvider(_priceProvidersRepository, _diaOracle, _stableAsset) {\n    }\n\n    /// @param _key string under this key asset price will be available in DIA oracle\n    /// @return assetPriceInUsd uint128 asset price\n    /// @return priceUpToDate bool TRUE if price is up to date (acceptable), FALSE otherwise\n    function getPriceForKey(string memory _key)\n        public\n        view\n        virtual\n        override\n        returns (uint128 assetPriceInUsd, bool priceUpToDate)\n    {\n        uint128 priceTimestamp;\n        (assetPriceInUsd, priceTimestamp) = DIA_ORACLEV2.getValue(_key);\n\n        // price must be updated at least once every 24h, otherwise something is wrong\n        uint256 oldestAcceptedPriceTimestamp;\n        // block.timestamp is more than HEARTBEAT, so we can not underflow\n        unchecked { oldestAcceptedPriceTimestamp = block.timestamp - 1 days - 10 minutes; }\n\n        // we not checking assetPriceInUsd != 0, because this is checked on setup, so it will be always some value here\n        priceUpToDate = priceTimestamp > oldestAcceptedPriceTimestamp;\n    }\n}\n"
    },
    "contracts/priceProviders/IERC20LikeV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6;\n\n/// @dev This is only meant to be used by price providers, which use a different\n/// Solidity version than the rest of the codebase. This way de won't need to include\n/// an additional version of OpenZeppelin's library.\ninterface IERC20LikeV2 {\n    function decimals() external view returns (uint8);\n    function balanceOf(address) external view returns(uint256);\n}\n"
    },
    "contracts/priceProviders/PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\nimport \"../lib/Ping.sol\";\nimport \"../interfaces/IPriceProvider.sol\";\nimport \"../interfaces/IPriceProvidersRepository.sol\";\n\n/// @title PriceProvider\n/// @notice Abstract PriceProvider contract, parent of all PriceProviders\n/// @dev Price provider is a contract that directly integrates with a price source, ie. a DEX or alternative system\n/// like Chainlink to calculate TWAP prices for assets. Each price provider should support a single price source\n/// and multiple assets.\nabstract contract PriceProvider is IPriceProvider {\n    /// @notice PriceProvidersRepository address\n    IPriceProvidersRepository public immutable priceProvidersRepository;\n\n    /// @notice Token address which prices are quoted in. Must be the same as PriceProvidersRepository.quoteToken\n    address public immutable override quoteToken;\n\n    modifier onlyManager() {\n        if (priceProvidersRepository.manager() != msg.sender) revert(\"OnlyManager\");\n        _;\n    }\n\n    /// @param _priceProvidersRepository address of PriceProvidersRepository\n    constructor(IPriceProvidersRepository _priceProvidersRepository) {\n        if (\n            !Ping.pong(_priceProvidersRepository.priceProvidersRepositoryPing)            \n        ) {\n            revert(\"InvalidPriceProviderRepository\");\n        }\n\n        priceProvidersRepository = _priceProvidersRepository;\n        quoteToken = _priceProvidersRepository.quoteToken();\n    }\n\n    /// @inheritdoc IPriceProvider\n    function priceProviderPing() external pure override returns (bytes4) {\n        return this.priceProviderPing.selector;\n    }\n\n    function _revertBytes(bytes memory _errMsg, string memory _customErr) internal pure {\n        if (_errMsg.length > 0) {\n            assembly { // solhint-disable-line no-inline-assembly\n                revert(add(32, _errMsg), mload(_errMsg))\n            }\n        }\n\n        revert(_customErr);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}